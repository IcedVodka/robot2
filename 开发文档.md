# 机器人控制系统开发文档

## 项目概述

### 项目背景
现有代码存在以下问题：
- 多个模块直接操作OpenCV窗口，容易产生冲突
- 相机资源管理混乱，不同模块独立初始化相机
- 代码耦合度高，模块间相互依赖
- 缺乏统一的架构设计，难以维护和扩展

### 重构目标
- 建立统一的窗口管理系统
- 实现传感器抽象和按需加载
- 分离数据处理和显示逻辑
- 提高代码可维护性和可扩展性

## 项目结构

```
my_robot/
├── main.py                    # 主程序入口
├── configs/                   # 配置文件
│   ├── __init__.py
│   ├── robot_config.yaml      # 机械臂配置
│   ├── sensor_config.yaml     # 传感器配置
│   └── window_config.yaml     # 窗口配置
├── modules/                   # 功能模块
│   ├── __init__.py
│   ├── hand_teleop.py        # 手势遥操作模块
│   ├── segmentation.py       # 图像分割模块
│   └── robot_control.py      # 机械臂控制模块
├── utils/                     # 工具模块
│   ├── __init__.py
│   ├── robot/                # 机器人相关
│   │   ├── __init__.py
│   │   ├── realman_controller.py
│   │   └── robot_interface.py
│   ├── models/               # 模型相关
│   │   ├── __init__.py
│   │   ├── hand_detector.py
│   │   ├── image_segmenter.py
│   │   └── model_manager.py
│   ├── sensor/               # 传感器相关
│   │   ├── __init__.py
│   │   ├── sensor_base.py    # 传感器基类
│   │   ├── rgb_camera.py     # RGB相机
│   │   ├── depth_camera.py   # 深度相机
│   │   ├── suction_sensor.py # 吸盘传感器
│   │   └── sensor_manager.py # 传感器管理器
│   ├── window_manager.py     # 窗口管理器
│   ├── config_manager.py     # 配置管理器
│   └── logger.py             # 日志工具
├── assets/                    # 资源文件
│   ├── models/               # AI模型文件
│   │   ├── yolov8s-world.pt
│   │   └── sam_b.pt
│   ├── robots/               # 机器人模型
│   └── hand_teleop_config/   # 手势配置
└── tests/                    # 测试文件
    ├── __init__.py
    ├── test_sensors.py
    ├── test_modules.py
    └── test_window_manager.py
```

## 核心组件设计

### 1. 传感器系统 (utils/sensor/)

#### 1.1 传感器基类
```python
# utils/sensor/sensor_base.py
class Sensor:
    def __init__(self, name, buffer_size=10):
        self.name = name
        self.buffer = queue.Queue(maxsize=buffer_size)
        self.running = False
        self.thread = None
    
    def start(self)
    def stop(self)
    def get_latest_data(self)
    def is_available(self)
```

#### 1.2 吸盘传感器
```python
# utils/sensor/suction_sensor.py
class SuctionSensor(Sensor):
    def __init__(self, port='/dev/ttyUSB0', baud_rate=115200):
        super().__init__("suction")
        self.port = port
        self.baud_rate = baud_rate
        self.ser = None
        self.state = "release"  # "suck" or "release"
    
    def suck(self):
        """吸盘吸气"""
        self._send_command("suck")
        self.state = "suck"
    
    def release(self):
        """吸盘释放"""
        self._send_command("release")
        self.state = "release"
    
    def get_status(self):
        """获取当前状态"""
        return {
            "state": self.state,
            "available": self.is_available()
        }
```

#### 1.3 传感器管理器
```python
# utils/sensor/sensor_manager.py
class SensorManager:
    def __init__(self):
        self.sensors = {}
    
    def get_sensor(self, sensor_type, **kwargs):
        """按需获取传感器"""
        if sensor_type not in self.sensors:
            if sensor_type == "rgb":
                self.sensors[sensor_type] = RGBCamera(**kwargs)
            elif sensor_type == "depth":
                self.sensors[sensor_type] = DepthCamera(**kwargs)
            elif sensor_type == "suction":
                self.sensors[sensor_type] = SuctionSensor(**kwargs)
        return self.sensors[sensor_type]
    
    def release_sensor(self, sensor_type):
        """释放传感器"""
        if sensor_type in self.sensors:
            self.sensors[sensor_type].stop()
            del self.sensors[sensor_type]
```

### 2. 机器人系统 (utils/robot/)

#### 2.1 机械臂控制器
```python
# utils/robot/realman_controller.py
class RealmanController:
    def __init__(self, name, ip, port):
        self.name = name
        self.ip = ip
        self.port = port
        self.robot = None
    
    def connect(self)
    def disconnect(self)
    def set_joints(self, joints)
    def get_joints(self)
    def set_hand_angles(self, angles)
```

#### 2.2 机器人管理器
```python
# utils/robot/robot_manager.py
class RobotManager:
    def __init__(self):
        self.master = None
        self.slave = None
        self.teleop = None
    
    def init_teleop(self, master_ip, slave_ip):
        """初始化遥操作"""
        self.master = RealmanController("master", master_ip, 8080)
        self.slave = RealmanController("slave", slave_ip, 8080)
        self.teleop = TeleoperationController(self.master, self.slave)
    
    def update_hand_control(self, hand_data):
        """更新手部控制"""
        if self.teleop:
            self.teleop.update_hand(hand_data)
```

### 3. 模型系统 (utils/models/)

#### 3.1 模型管理器
```python
# utils/models/model_manager.py
class ModelManager:
    def __init__(self, model_dir):
        self.model_dir = model_dir
        self.models = {}
    
    def load_model(self, model_type):
        """按需加载模型"""
        if model_type not in self.models:
            if model_type == "yolo":
                self.models[model_type] = YOLO(f"{self.model_dir}/yolov8s-world.pt")
            elif model_type == "sam":
                self.models[model_type] = SAMPredictor(f"{self.model_dir}/sam_b.pt")
        return self.models[model_type]
```

### 4. 功能模块 (modules/)

#### 4.1 手势遥操作模块
```python
# modules/hand_teleop.py
class HandTeleopModule:
    def __init__(self, sensor_manager, robot_manager, window_manager):
        self.sensor_manager = sensor_manager
        self.robot_manager = robot_manager
        self.window_manager = window_manager
        self.hand_detector = None
        self.rgb_sensor = None
    
    def start(self):
        """启动模块"""
        self.rgb_sensor = self.sensor_manager.get_sensor("rgb")
        self.hand_detector = HandDetector()
        self.rgb_sensor.start()
    
    def stop(self):
        """停止模块"""
        if self.rgb_sensor:
            self.sensor_manager.release_sensor("rgb")
    
    def process(self):
        """处理逻辑"""
        frame = self.rgb_sensor.get_latest_data()
        if frame is not None:
            result = self.hand_detector.detect(frame)
            return {
                "window_name": "手势检测",
                "frame": result["visualization"],
                "hand_data": result["landmarks"],
                "status": "success"
            }
        return {"status": "no_data"}
```

#### 4.2 图像分割模块
```python
# modules/segmentation.py
class SegmentationModule:
    def __init__(self, sensor_manager, window_manager):
        self.sensor_manager = sensor_manager
        self.window_manager = window_manager
        self.segmenter = None
        self.depth_sensor = None
    
    def start(self):
        """启动模块"""
        self.depth_sensor = self.sensor_manager.get_sensor("depth")
        self.segmenter = ImageSegmentation()
        self.depth_sensor.start()
    
    def stop(self):
        """停止模块"""
        if self.depth_sensor:
            self.sensor_manager.release_sensor("depth")
    
    def process(self):
        """处理逻辑"""
        frames = self.depth_sensor.get_latest_data()
        if frames is not None:
            result = self.segmenter.segment(frames)
            return {
                "window_name": "图像分割",
                "frame": result["visualization"],
                "grasp_pose": result["grasp_pose"],
                "status": "success"
            }
        return {"status": "no_data"}
```

### 5. 主程序 (main.py)

```python
# main.py
def main():
    # 初始化管理器
    config_manager = ConfigManager()
    sensor_manager = SensorManager()
    robot_manager = RobotManager()
    window_manager = WindowManager()
    
    # 初始化模块
    hand_teleop = HandTeleopModule(sensor_manager, robot_manager, window_manager)
    segmentation = SegmentationModule(sensor_manager, window_manager)
    
    current_module = None
    
    try:
        while running:
            # 处理当前模块
            if current_module == "hand_teleop":
                result = hand_teleop.process()
                if result["status"] == "success":
                    window_manager.show(result["window_name"], result["frame"])
                    robot_manager.update_hand_control(result["hand_data"])
            
            elif current_module == "segmentation":
                result = segmentation.process()
                if result["status"] == "success":
                    window_manager.show(result["window_name"], result["frame"])
            
            # 处理用户输入
            key = cv2.waitKey(1)
            if key == ord('1'):
                # 切换到手势遥操作
                if current_module != "hand_teleop":
                    if current_module == "segmentation":
                        segmentation.stop()
                    hand_teleop.start()
                    current_module = "hand_teleop"
            
            elif key == ord('2'):
                # 切换到图像分割
                if current_module != "segmentation":
                    if current_module == "hand_teleop":
                        hand_teleop.stop()
                    segmentation.start()
                    current_module = "segmentation"
    
    finally:
        # 清理资源
        hand_teleop.stop()
        segmentation.stop()
```

## 开发计划

### 第一阶段：基础框架 (今天上午)
1. 创建项目目录结构
2. 实现传感器基类
3. 实现窗口管理器
4. 实现配置管理器

### 第二阶段：传感器实现 (今天下午)
1. 实现RGB相机传感器
2. 实现深度相机传感器
3. 实现吸盘传感器
4. 实现传感器管理器

### 第三阶段：模块迁移 (今天晚上)
1. 迁移手势检测模块
2. 迁移图像分割模块
3. 迁移机械臂控制模块
4. 实现主程序框架

### 第四阶段：测试验证 (明天)
1. 单元测试
2. 集成测试
3. 性能优化
4. 文档完善

## 技术规范

### 线程模型
- 采用单线程主循环
- 传感器使用独立线程采集数据
- 主线程负责窗口管理和模块协调

### 数据流
```
传感器 → 缓冲队列 → 模块处理 → 结果返回 → 主程序 → 窗口显示
```

### 错误处理
- 传感器初始化失败处理
- 窗口创建失败处理
- 模块处理异常处理
- 资源清理异常处理

## 配置管理

### 1. 机器人配置 (configs/robot_config.yaml)
```yaml
robot:
  master:
    ip: "192.168.1.19"
    port: 8080
  slave:
    ip: "192.168.1.18"
    port: 8080
  hand:
    grip_angles: [1000, 14000, 14000, 14000, 14000, 10000]
    release_angles: [4000, 17800, 17800, 17800, 17800, 10000]
```

### 2. 传感器配置 (configs/sensor_config.yaml)
```yaml
sensors:
  rgb:
    camera_id: 0
    width: 640
    height: 480
    fps: 30
  depth:
    width: 640
    height: 480
    fps: 30
  suction:
    port: "/dev/ttyUSB0"
    baud_rate: 115200
```

### 3. 窗口配置 (configs/window_config.yaml)
```yaml
windows:
  hand_detection:
    title: "手势检测"
    size: [640, 480]
    position: [0, 0]
  segmentation:
    title: "图像分割"
    size: [640, 480]
    position: [650, 0]
```

## 日志系统

### 日志配置
```python
# utils/logger.py
import logging

def setup_logger():
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler('robot_system.log'),
            logging.StreamHandler()
        ]
    )
```

## 验收标准

### 功能验收
- 所有模块能正常切换
- 窗口显示正常
- 传感器数据采集正常
- 机械臂控制正常

### 性能验收
- 窗口更新延迟 < 33ms (30fps)
- 传感器数据延迟 < 100ms
- 模块切换时间 < 1s

### 稳定性验收
- 连续运行24小时无异常
- 异常恢复正常
- 资源清理完整 